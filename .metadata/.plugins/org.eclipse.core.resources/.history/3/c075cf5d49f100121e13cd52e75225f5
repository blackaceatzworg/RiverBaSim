package riverbasim;

import java.io.File;
import java.io.IOException;

import repast.simphony.context.Context;
import repast.simphony.context.DefaultContext;
import repast.simphony.dataLoader.ContextBuilder;
import repast.simphony.engine.environment.RunEnvironment;
import repast.simphony.space.gis.Geography;
import repast.simphony.space.graph.Network;
import repast.simphony.space.graph.ShortestPath;

public class ContextCreator implements ContextBuilder<Object>
{
	private static Context<Object> mainContext; // Useful to keep a reference to
												// the main context
	private static int agentID; // Used to generate unique agent ids

	/**
	 * Used to build the model, creating all subcontexts.
	 */
	public Context<Object> build(Context<Object> context)
	{		
		ContextCreator.mainContext = context;

		RiverBaSimContext cityContext = new CityContext();
		context.addSubContext(cityContext);
		cityContext.createSubContexts();
//		cityContext.buildRoadNetwork();
//		testRoadNetwork();

		DriverContext personContext = new DriverContext();
		context.addSubContext(personContext);

		return context;
	}

	/**
	 * Creates a unique identifier for an agent. IDs are created in ascending
	 * order.
	 * 
	 * @return the unique identifier.
	 */
	public static int generateAgentID()
	{
		return ContextCreator.agentID++;
	}

	public void testRoadNetwork()
	{
		// Quick test of the city context to see if the city has been created
		// successfully.
		System.out.println("Testing city: getting 100 random origins and destinations and seeing if there is "
						+ "a route between them, throwing an error if not:");
		int num = 100;
		for (int i = 0; i < num; i++)
		{
			Junction origin = getJunctionContext().getRandomObject();
			Junction destination = getJunctionContext().getRandomObject();
			double l = new ShortestPath<Junction>(getRoadNetwork()).getPathLength(origin, destination);
			System.out.println("origin: " + origin.getRoads() + ", destination: " + destination.getRoads());
			if (!origin.equals(destination))
			{
				 System.out.println("Found path between "+origin.toString()+" and "+
				 destination.toString()+", length: " + l);
			} // if
		} // for
		System.out.println("Test completed (if no errors then it was successfull)");
	}

	/*
	 * These static methods are useful for getting projections and contexts but
	 * not essential (Repast supplies methods to do this. Not sure how to get
	 * rid of the warnings, please tell me if you know!
	 */

	public static DriverContext getDriverContext()
	{
		return (DriverContext) mainContext.findContext("DriverContext");
	}

	@SuppressWarnings("unchecked")
	public static Geography<Driver> getPersonGeography()
	{
		return (Geography<Driver>) ContextCreator.getDriverContext()
				.getProjection("DriverGeography");
	}

	public static Geography<Driver> getDriverGeography()
	{
		return driverGeography;
	}

	public static JunctionContext getJunctionContext()
	{
		return (JunctionContext) mainContext.findContext("JunctionContext");
	}

	@SuppressWarnings("unchecked")
	public static Geography<Junction> getJunctionGeography()
	{
		return (Geography<Junction>) ContextCreator.getJunctionContext().getProjection("JunctionGeography");
	}

	@SuppressWarnings("unchecked")
	public static Network<Junction> getRoadNetwork()
	{
		return (Network<Junction>) ContextCreator.getJunctionContext().getProjection("RoadNetwork");
	}

	public static RoadContext getRoadContext()
	{
		return (RoadContext) mainContext.findContext("RoadContext");
	}

	@SuppressWarnings("unchecked")
	public static Geography<Road> getRoadGeography()
	{
		return (Geography<Road>) ContextCreator.getRoadContext().getProjection(
				"RoadGeography");
	}

	public static CityContext getCityContext()
	{
		return (CityContext) mainContext.findContext("CityContext");
	}

//	public static HouseContext getHouseContext()
//	{
//		return (HouseContext) mainContext.findContext("HouseContext");
//	}
//
//	public static Geography<House> getHouseGeography()
//	{
//		return (Geography<House>) ContextCreator.getHouseContext()
//				.getProjection("HouseGeography");
//	}
	
	public static POIContext getPOIContext()
	{
		return (POIContext) mainContext.findContext("POIContext");
	}

	@SuppressWarnings("unchecked")
	public static Geography<POI> getPOIGeography()
	{
		return (Geography<POI>)ContextCreator.getPOIContext().getProjection("POIGeography");
	}
	
	public static void main(String args[])
	{
		ContextCreator	cc;
		
		cc = new ContextCreator();
		cc.build(new DefaultContext<Object>());
	}

	public Context<Object> getMainContext()
	{
		return mainContext;
	}
	
	public static DroolsEngine getRuleEngine()
	{
		return engine;
	}

	public static void setDriverGeography(Geography<Driver> driverGeography2)
	{
		driverGeography = driverGeography2;
	}

	public static RechargePointContext getRechargePointContext()
	{
		return (RechargePointContext)mainContext.findContext("RechargePointContext");
	}
}
