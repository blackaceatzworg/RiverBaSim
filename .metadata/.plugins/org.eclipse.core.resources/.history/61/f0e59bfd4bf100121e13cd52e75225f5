package riverbasim;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map.Entry;

import repast.simphony.context.DefaultContext;
import repast.simphony.context.space.gis.GeographyFactoryFinder;
import repast.simphony.context.space.graph.NetworkBuilder;
import repast.simphony.space.gis.Geography;
import repast.simphony.space.gis.GeographyParameters;
import repast.simphony.space.graph.Network;
import repast.simphony.space.graph.RepastEdge;

public class FlowContext extends DefaultContext<RiverSection> {
	private Map<String,RiverBlock>	blocks;
	
	public FlowContext()
	{
		super("FlowContext");

		System.out.println("FlowContext: building river flow context and projections");
		roads = new HashMap<String,RiverBlock>();
		
		/*
		 * GIS projection for spatial information about Roads. This is used to
		 * then create junctions and finally the road network.
		 */
		GeographyParameters<Road> geoParams = new GeographyParameters<Road>();
		Geography<Road> roadGeography = GeographyFactoryFinder
				.createGeographyFactory(null).createGeography("RoadGeography",
						this, geoParams);

		/* Read in the data and add to the context and geography */
		File roadFile = null;
		ShapefileLoader<Road> roadLoader = null;
		try
		{
			roadFile = new File(GlobalVariables.ROADS_SHAPEFILE);
			roadLoader = new ShapefileLoader<Road>(Road.class,
					roadFile.toURI().toURL(), roadGeography, this);
			while(roadLoader.hasNext())
			{
				roadLoader.next();
			}

		}
		catch (java.net.MalformedURLException e)
		{
			System.out
					.println("ContextCreator: malformed URL exception when reading roadshapefile. Check the 'roadLoc' parameter is correct");
			e.printStackTrace();
		}
	}

	public void addRoad(Road road)
	{
		roads.put(road.getName(), road);
	}

	public FlowContext(RiverBaSimContext rc) {
		super("FlowContext"); // must match name in model.score
		GeographyParameters<RiverSection> geoParamsFlow = new GeographyParameters<RiverSection>();
		flowGeography = GeographyFactoryFinder
				.createGeographyFactory(null).createGeography("FlowGeography",
						this, geoParamsFlow);
		System.out.println("Created FlowGeography");
		NetworkBuilder<RiverSection> builder = new NetworkBuilder<RiverSection>("FlowNetwork", this, false);
		network = builder.buildNetwork();
		HashMap<RiverSection, RiverSection> flow = rc.flow;
		if(flow != null) {
			assignEdges(flow);
		}
	}

	public void assignEdges(HashMap<RiverSection, RiverSection> flow) {
		Iterator<Entry<RiverSection,RiverSection>> itMap = flow.entrySet().iterator();
		while(itMap.hasNext()) {
			Entry<RiverSection,RiverSection> entry = itMap.next();
			RiverSection origin, destination;
			origin = entry.getKey();
			destination = entry.getValue();
			if(origin != null && destination != null) {
				RepastEdge<RiverSection> edge = new RepastEdge<RiverSection>(origin, destination, false);
				network.addEdge(edge);
			}
		}
	}
}
