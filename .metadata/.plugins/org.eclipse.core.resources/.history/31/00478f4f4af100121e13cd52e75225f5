package riverbasim;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.channels.FileChannel;
import java.nio.charset.Charset;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import org.geotools.data.shapefile.dbf.DbaseFileReader;
import org.geotools.data.shapefile.dbf.DbaseFileReader.Row;

import repast.simphony.context.DefaultContext;
import repast.simphony.context.space.gis.GeographyFactoryFinder;
import repast.simphony.space.gis.Geography;
import repast.simphony.space.gis.GeographyParameters;
import repast.simphony.space.gis.Road;
import repast.simphony.space.gis.ShapefileLoader;

import com.vividsolutions.jts.geom.Coordinate;
import com.vividsolutions.jts.geom.Geometry;
import com.vividsolutions.jts.geom.GeometryFactory;
import com.vividsolutions.jts.geom.MultiLineString;
import com.vividsolutions.jts.geom.Point;
import com.vividsolutions.jts.operation.distance.DistanceOp;

import edu.uci.ics.jung.graph.Graph;

public class RiverBaSimContext extends DefaultContext<Object> {
	private HashSet<RiverSection> setBesos;
	HashMap<RiverSection,RiverSection> flow = null;

	private Graph<RiverSection,RiverBlock>	graph;
	
	/**
	 * Constructs a CityContextContext and creates a Geography (called
	 * RoadNetworkGeography) which is part of this context.
	 */
	public RiverBaSimContext()
	{
		super("RiverBaSimContext"); // Very important otherwise repast complains

		System.out.println("RiverBaSimContext: Building RiverBaSim context");

		/* Create a geography to display the sub-contexts of the city. */
		GeographyParameters<Object> geoParams = new GeographyParameters<Object>();
		GeographyFactoryFinder.createGeographyFactory(null).createGeography(
				"RiverBaSimGeography", this, geoParams);
	}

	public void createSubContexts()
	{
		this.addSubContext(new RoadContext());
		this.addSubContext(new JunctionContext());
		
		buildRoadNetwork();
		asj = new AStarJunction(graph);
		
		this.addSubContext(new POIContext());
		this.addSubContext(new RechargePointContext());
	}
	
	public AStarJunction getAlgorithm()
	{
		return asj;
	}

	/*
	 * Returns the road which is crosses the given coordinates (Actually it just
	 * returns the *nearest* road to the coords)
	 */
	public Road findRoadAtCoordinates(Coordinate coord)
	{
		GeometryFactory geomFac = new GeometryFactory();
		Geography<?> roadGeography = ContextCreator.getRoadGeography();
		// Use a buffer for efficiency
		Point point = geomFac.createPoint(coord);
		Geometry buffer = point.buffer(0.01); // XXXX - Parameter
		double minDist = 999999999.9;
		Road nearestRoad = null;
		for (Road road : roadGeography.getObjectsWithin(buffer
				.getEnvelopeInternal(), Road.class))
		{
			DistanceOp distOp = new DistanceOp(point, roadGeography
					.getGeometry(road));
			double thisDist = distOp.distance();
			if (thisDist < minDist)
			{
				minDist = thisDist;
				nearestRoad = road;
			} // if thisDist < minDist
		} // for nearRoads
		if (nearestRoad == null)
		{
			System.err
					.println("CityContext: findRoadAtCoordinates: ERROR: couldn't find a road at these coordinates:\n\t"
							+ coord.toString());
		}
		return nearestRoad;
	}

	public Road findRoadWithID(String id)
	{
		Geography<Road> roadGeography = (Geography<Road>) ContextCreator
				.getRoadGeography();
		for (Road road : roadGeography.getAllObjects())
		{
			if (road.getIdentifier().equals(id))
				return road;
		}
		System.err
				.println("CityContext: findRoadWithID: Error, couldn't find a road woth id: "
						+ id);
		return new Road();
	}

	public void buildRoadNetwork()
	{
		Geography<Road>		roadGeography;
		Geography<Junction>	junctionGeography;
		JunctionContext		junctionContext;
		GeometryFactory		geomFac;
		Iterator<Road>		roadIt;
		Road				road, piece;
		Geometry			roadGeom;
		int					i;
		Coordinate			c1, c2;
		Junction			junc1, junc2;
		
		graph = new Multigraph<Junction,Road>(Road.class);
		System.out.println("CityContext: building road network graph");
		
		roadGeography = (Geography<Road>)ContextCreator.getRoadGeography();
		junctionGeography = (Geography<Junction>)ContextCreator.getJunctionGeography();
		junctionContext = (JunctionContext)ContextCreator.getJunctionContext();
		
		geomFac = new GeometryFactory();
		
		// Iterate through all roads
		roadIt = roadGeography.getAllObjects().iterator();
		while(roadIt.hasNext())
		{
			road = roadIt.next();
			if (road.getName() != null && !road.getName().trim().equals(""))
			{
				roadGeom = roadGeography.getGeometry(road);
				System.out.println(road.getName() + ":" + road.getIdentifier() + " has " + roadGeom.getCoordinates().length + " points");

				for(i = 0; i <= roadGeom.getNumPoints() - 2; i++)
				{
					piece = new Road();
					piece.setName(road.getName());
					
					road.addSubroad(piece);
					
					c1 = roadGeom.getCoordinates()[i];
					c2 = roadGeom.getCoordinates()[i + 1];
					
					// Create Junctions from these coordinates and add them to the
					// JunctionGeography (if they haven't been created already)
					junc1 = checkJunction(junctionContext, junctionGeography, geomFac, c1);
					junc2 = checkJunction(junctionContext, junctionGeography, geomFac, c2);
					
					// Tell the junctions about this road
					junc1.addRoad(piece);
					junc2.addRoad(piece);
					
					// Tell the road object who it's junctions are
					piece.addJunction(junc1);
					piece.addJunction(junc2);

					graph.addVertex(junc1);
					graph.addVertex(junc2);
					graph.addEdge(junc1, junc2, piece);
				}
			}
		}
	}

	private Junction checkJunction(JunctionContext junctionContext, Geography<Junction> junctionGeography, GeometryFactory geomFac, Coordinate c)
	{
		Junction	j;
		Point		p;
		
		j = junctionContext.getJunctionWithCoordinates(c);
		if(j == null)
		{
			j = new Junction(c);
			junctionContext.add(j);
			junctionContext.addToMap(j);
			p = geomFac.createPoint(c);
			junctionGeography.move(j, p);
		}
		
		return j;
	}

	public Graph<Junction,Road> getGraph()
	{
		return graph;
	}

	public RiverBaSimContext() {
		super("RiverBaSimContext"); // must match name in model.score
		GeographyParameters<RiverSection> geoParams = new GeographyParameters<RiverSection>();
		Geography<RiverSection> riverGeography = GeographyFactoryFinder
				.createGeographyFactory(null).createGeography("RiverGeography",
						this, geoParams);
		System.out.println("Created RiverGeography");

		File selectedFile = new File("./contrib/x_besos/x_besos.dbf");
		FileChannel in = null;
		try {
			in = new FileInputStream(selectedFile).getChannel();
		} catch (FileNotFoundException ex) {
			Logger.getLogger(getClass().getName()).log(Level.DEBUG, null, ex);
		}
		DbaseFileReader r = null;
		try {
			r = new DbaseFileReader(in, false, Charset.forName("ISO-8859-1"));
		} catch (IOException ex1) {
			Logger.getLogger(getClass().getName()).log(Level.DEBUG, null, ex1);
		}

		Object[] fields = new Object[r.getHeader().getNumFields()];
		while (r.hasNext()) {
			try {
				r.readEntry(fields);
				Row row = r.readRow();
				System.out.println(row);
			} catch (IOException ex1) {
				Logger.getLogger(getClass().getName()).log(Level.DEBUG, null,
						ex1);
			}
		}
		try {
			r.close();
		} catch (IOException ex1) {
			Logger.getLogger(getClass().getName()).log(Level.DEBUG, null, ex1);
		}

		File shapefile = null;
		ShapefileLoader<RiverSection> riverLoader = null;
		try {
			shapefile = new File("./contrib/x_besos/x_besos.shp");
			riverLoader = new ShapefileLoader<RiverSection>(RiverSection.class,
					shapefile.toURL(), riverGeography, this);
		} catch (java.net.MalformedURLException e) {
			e.printStackTrace();
		}
		while (riverLoader.hasNext()) {
			riverLoader.next();
		}

		setBesos = new HashSet<RiverSection>();
		for (RiverSection p : riverGeography.getAllObjects()) {
			Geometry geom = riverGeography.getGeometry(p);
			Coordinate coord = geom.getCoordinate();
			MultiLineString line = (MultiLineString)geom;
			if(p.getNom().startsWith("el Bes˜s")) {
				setBesos.add(p);
				System.out.println(p.getNom() + " is at: (" + coord.x + ","
						+ coord.y + ") [size of set: " + setBesos.size() + "]");
			} else {
				this.remove(p);
			}
		}
		
		flow = new HashMap<RiverSection,RiverSection>();
		HashSet<RiverSection> tempBesos = new HashSet<RiverSection>();
		tempBesos.addAll(setBesos);
		Iterator<RiverSection> it1, it2;
		it1 = setBesos.iterator();
		while(it1.hasNext()) {
			RiverSection p1 = it1.next();
			Geometry geom1 = riverGeography.getGeometry(p1);
			Coordinate coord1 = geom1.getCoordinate();
			MultiLineString line1 = (MultiLineString)geom1;
			tempBesos.remove(p1);
			it2 = tempBesos.iterator();
			double min = Double.POSITIVE_INFINITY;
			RiverSection nearest = null;
			while(it2.hasNext()) {
				RiverSection p2 = it2.next();
				Geometry geom2 = riverGeography.getGeometry(p2);
				Coordinate coord2 = geom2.getCoordinate();
				MultiLineString line2 = (MultiLineString)geom2;
				double candidate = coord1.distance(coord2);
				if(candidate < min) {
					nearest = p2;
					min = candidate;
				}
			}
			flow.put(p1, nearest);
		}
		
		FlowContext fc = (FlowContext)this.findContext("FlowContext");
		if(fc != null) {
			fc.assignEdges(flow);
		}
		
		this.addSubContext(new FlowContext(this));
	}
}
